const VulnerabilityModel = require('../models/vulnerabilityModel');
const UserModel = require('../models/userModel');
const ActivityLogModel = require('../models/activityLogModel');
const { addExperience, checkAchievements } = require('./userController');
const { validateRequired, validatePagination, sanitizeInput } = require('../utils/validation');

// Helper function to validate status
const validateStatus = (status) => {
    const validStatuses = ['open', 'in_progress', 'resolved', 'closed'];
    return validStatuses.includes(status);
};

// Create vulnerability
const createVulnerability = (req, res) => {
    const { title, description, severity } = req.body;
    const reporterId = req.userId;

    // Validate required fields
    const validation = validateRequired({ title, description, severity });
    if (!validation.isValid) {
        return res.status(400).json({ 
            success: false, 
            message: validation.message 
        });
    }

    // Validate severity
    const validSeverities = ['low', 'medium', 'high', 'critical'];
    if (!validSeverities.includes(severity)) {
        return res.status(400).json({ 
            success: false, 
            message: 'Invalid severity. Must be: low, medium, high, or critical' 
        });
    }

    // Sanitize inputs
    const sanitizedTitle = sanitizeInput(title);
    const sanitizedDescription = sanitizeInput(description);

    // Calculate EXP reward based on severity
    const expRewards = { low: 50, medium: 100, high: 200, critical: 500 };
    const expReward = expRewards[severity];

    const vulnerabilityData = {
        title: sanitizedTitle,
        description: sanitizedDescription,
        severity,
        expReward,
        reporterId
    };

    VulnerabilityModel.create(vulnerabilityData, (error, result) => {
        if (error) {
            console.error('Create vulnerability error:', error);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        // Add experience to user
        addExperience(reporterId, expReward, (expError) => {
            if (expError) {
                console.error('Add experience error:', expError);
            }
        });

        // Check for achievements
        checkAchievements(reporterId, (achError) => {
            if (achError) {
                console.error('Check achievements error:', achError);
            }
        });

        // Log activity
        ActivityLogModel.create({
            userId: reporterId,
            actionType: 'vulnerability_reported',
            details: { 
                vulnerabilityId: result.insertId,
                title: sanitizedTitle,
                severity
            }
        }, (logError) => {
            if (logError) {
                console.error('Activity log error:', logError);
            }
        });

        res.status(201).json({
            success: true,
            message: 'Vulnerability reported successfully',
            vulnerability: {
                id: result.insertId,
                title: sanitizedTitle,
                description: sanitizedDescription,
                severity,
                exp_reward: expReward
            }
        });
    });
};

// Get vulnerabilities
const getVulnerabilities = (req, res) => {
    const { page = 1, limit = 10, status, severity } = req.query;
    const validation = validatePagination(page, limit);
    
    if (!validation.isValid) {
        return res.status(400).json({ 
            success: false, 
            message: validation.message 
        });
    }

    const offset = (validation.page - 1) * validation.limit;
    const filters = { status, severity };

    VulnerabilityModel.getAll(filters, validation.limit, offset, (error, vulnerabilities) => {
        if (error) {
            console.error('Get vulnerabilities error:', error);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        // Get total count for pagination
        VulnerabilityModel.getTotalCount(filters, (countError, countResult) => {
            if (countError) {
                console.error('Get vulnerability count error:', countError);
            }

            const totalCount = countResult && countResult.length > 0 ? countResult[0].total : 0;

            res.json({
                success: true,
                vulnerabilities,
                pagination: {
                    page: validation.page,
                    limit: validation.limit,
                    total: totalCount,
                    totalPages: Math.ceil(totalCount / validation.limit)
                }
            });
        });
    });
};

// Get single vulnerability
const getVulnerability = (req, res) => {
    const { id } = req.params;

    VulnerabilityModel.findById(id, (error, vulnerabilities) => {
        if (error) {
            console.error('Get vulnerability error:', error);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        if (vulnerabilities.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Vulnerability not found' 
            });
        }

        res.json({
            success: true,
            vulnerability: vulnerabilities[0]
        });
    });
};

// Update vulnerability status
const updateVulnerabilityStatus = (req, res) => {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
        return res.status(400).json({ 
            success: false, 
            message: 'Status is required' 
        });
    }

    if (!validateStatus(status)) {
        return res.status(400).json({ 
            success: false, 
            message: 'Invalid status. Must be: open, in_progress, resolved, or closed' 
        });
    }

    // Get vulnerability details first
    VulnerabilityModel.findById(id, (findError, vulnerabilities) => {
        if (findError) {
            console.error('Find vulnerability error:', findError);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        if (vulnerabilities.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Vulnerability not found' 
            });
        }

        const vulnerability = vulnerabilities[0];
        const resolverId = status === 'resolved' ? req.userId : null;

        VulnerabilityModel.updateStatus(id, status, resolverId, (error, result) => {
            if (error) {
                console.error('Update vulnerability status error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            if (result.affectedRows === 0) {
                return res.status(404).json({ 
                    success: false, 
                    message: 'Vulnerability not found' 
                });
            }

            // If vulnerability is resolved, add experience to resolver
            if (status === 'resolved' && resolverId) {
                const resolverReward = Math.floor(vulnerability.exp_reward * 1.5); // 1.5x reward for resolving
                addExperience(resolverId, resolverReward, (expError) => {
                    if (expError) {
                        console.error('Add resolver experience error:', expError);
                    }
                });

                // Check for achievements
                checkAchievements(resolverId, (achError) => {
                    if (achError) {
                        console.error('Check resolver achievements error:', achError);
                    }
                });

                // Log activity
                ActivityLogModel.create({
                    userId: resolverId,
                    actionType: 'vulnerability_resolved',
                    details: { 
                        vulnerabilityId: id,
                        title: vulnerability.title,
                        expReward: resolverReward
                    }
                }, (logError) => {
                    if (logError) {
                        console.error('Activity log error:', logError);
                    }
                });
            }

            res.json({
                success: true,
                message: 'Vulnerability status updated successfully',
                vulnerability: {
                    id: parseInt(id),
                    status,
                    resolver_id: resolverId
                }
            });
        });
    });
};

// Get user's vulnerabilities
const getUserVulnerabilities = (req, res) => {
    const userId = req.params.userId || req.userId;
    const { type = 'reported' } = req.query;

    if (type === 'reported') {
        VulnerabilityModel.getUserReported(userId, (error, vulnerabilities) => {
            if (error) {
                console.error('Get user reported vulnerabilities error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            res.json({
                success: true,
                type: 'reported',
                vulnerabilities
            });
        });
    } else if (type === 'resolved') {
        VulnerabilityModel.getUserResolved(userId, (error, vulnerabilities) => {
            if (error) {
                console.error('Get user resolved vulnerabilities error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            res.json({
                success: true,
                type: 'resolved',
                vulnerabilities
            });
        });
    } else {
        res.status(400).json({
            success: false,
            message: 'Invalid type. Must be: reported or resolved'
        });
    }
};

module.exports = {
    createVulnerability,
    getVulnerabilities,
    getVulnerability,
    updateVulnerabilityStatus,
    getUserVulnerabilities
};