const VulnerabilityModel = require('../models/vulnerabilityModel');
const UserModel = require('../models/userModel');
const ActivityLogModel = require('../models/activityLogModel');
const { addExperience, checkAchievements } = require('./userController');
const { validateRequired, validatePagination, sanitizeInput } = require('../utils/validation');

// Helper function to validate status
const validateStatus = (status) => {
    const validStatuses = ['open', 'in_progress', 'resolved', 'closed'];
    return validStatuses.includes(status);
};

// Create vulnerability
const createVulnerability = (req, res) => {
    const { title, description, severity, category, steps_to_reproduce, impact } = req.body;
    const reporterId = req.userId;

    // Validate required fields
    const validation = validateRequired({ title, description, severity, category, steps_to_reproduce, impact });
    if (!validation.isValid) {
        return res.status(400).json({ 
            success: false, 
            message: validation.message 
        });
    }

    // Validate severity
    const validSeverities = ['low', 'medium', 'high', 'critical'];
    if (!validSeverities.includes(severity)) {
        return res.status(400).json({ 
            success: false, 
            message: 'Invalid severity. Must be: low, medium, high, or critical' 
        });
    }

    // Validate category
    const validCategories = ['xss', 'sqli', 'auth', 'idor', 'csrf', 'rce', 'other'];
    if (!validCategories.includes(category)) {
        return res.status(400).json({ 
            success: false, 
            message: 'Invalid category' 
        });
    }

    // Sanitize inputs
    const sanitizedTitle = sanitizeInput(title);
    const sanitizedDescription = sanitizeInput(description);
    const sanitizedSteps = sanitizeInput(steps_to_reproduce);
    const sanitizedImpact = sanitizeInput(impact);

    // Calculate EXP reward based on severity
    const expRewards = { low: 50, medium: 100, high: 200, critical: 500 };
    const expReward = expRewards[severity];

    const vulnerabilityData = {
        title: sanitizedTitle,
        description: sanitizedDescription,
        severity,
        category,
        steps_to_reproduce: sanitizedSteps,
        impact: sanitizedImpact,
        expReward,
        reporterId
    };

    VulnerabilityModel.create(vulnerabilityData, (error, result) => {
        if (error) {
            console.error('Create vulnerability error:', error);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        // Add experience to user
        addExperience(reporterId, expReward, (expError) => {
            if (expError) {
                console.error('Add experience error:', expError);
            }
        });

        // Log activity
        ActivityLogModel.create({
            userId: reporterId,
            action: 'vulnerability_reported',
            details: `Reported vulnerability: ${sanitizedTitle}`,
            exp_gained: expReward
        }, (logError) => {
            if (logError) {
                console.error('Activity log error:', logError);
            }
        });

        // Check for achievements
        checkAchievements(reporterId, 'vulnerability_reported', (achievementError) => {
            if (achievementError) {
                console.error('Achievement check error:', achievementError);
            }
        });

        res.status(201).json({
            success: true,
            message: 'Vulnerability reported successfully!',
            vulnerability: {
                id: result.insertId,
                ...vulnerabilityData
            },
            exp_earned: expReward
        });
    });
};

// Get vulnerabilities with filtering
const getVulnerabilities = (req, res) => {
    const { page = 1, limit = 10, status, severity, mine } = req.query;
    
    // Validate pagination
    const validation = validatePagination(page, limit);
    if (!validation.isValid) {
        return res.status(400).json({ 
            success: false, 
            message: validation.message 
        });
    }

    const filters = {};
    if (status) filters.status = status;
    if (severity) filters.severity = severity;
    if (mine === 'true' && req.userId) filters.reporter_id = req.userId;

    const offset = (validation.page - 1) * validation.limit;

    // Get total count for pagination
    VulnerabilityModel.getTotalCount(filters, (countError, countResult) => {
        if (countError) {
            console.error('Count vulnerabilities error:', countError);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        // Get vulnerabilities
        VulnerabilityModel.getAll(filters, validation.limit, offset, (error, vulnerabilities) => {
            if (error) {
                console.error('Get vulnerabilities error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            const totalCount = countResult && countResult.length > 0 ? countResult[0].total : 0;

            res.json({
                success: true,
                vulnerabilities,
                pagination: {
                    page: validation.page,
                    limit: validation.limit,
                    total: totalCount,
                    totalPages: Math.ceil(totalCount / validation.limit)
                }
            });
        });
    });
};

// Get single vulnerability
const getVulnerability = (req, res) => {
    const { id } = req.params;

    VulnerabilityModel.findById(id, (error, vulnerabilities) => {
        if (error) {
            console.error('Get vulnerability error:', error);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        if (vulnerabilities.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Vulnerability not found' 
            });
        }

        res.json({
            success: true,
            vulnerability: vulnerabilities[0]
        });
    });
};

// Update vulnerability status
const updateVulnerabilityStatus = (req, res) => {
    const { id } = req.params;
    const { status } = req.body;

    if (!status) {
        return res.status(400).json({ 
            success: false, 
            message: 'Status is required' 
        });
    }

    if (!validateStatus(status)) {
        return res.status(400).json({ 
            success: false, 
            message: 'Invalid status. Must be: open, in_progress, resolved, or closed' 
        });
    }

    // Get vulnerability details first
    VulnerabilityModel.findById(id, (findError, vulnerabilities) => {
        if (findError) {
            console.error('Find vulnerability error:', findError);
            return res.status(500).json({ 
                success: false, 
                message: 'Server error' 
            });
        }

        if (vulnerabilities.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Vulnerability not found' 
            });
        }

        const vulnerability = vulnerabilities[0];
        const resolverId = status === 'resolved' ? req.userId : null;

        // Update status
        VulnerabilityModel.updateStatus(id, status, resolverId, (error, result) => {
            if (error) {
                console.error('Update vulnerability status error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            // If resolved, add experience to resolver
            if (status === 'resolved' && resolverId) {
                const resolveExpReward = Math.floor(vulnerability.exp_reward * 0.5); // 50% of original reward
                addExperience(resolverId, resolveExpReward, (expError) => {
                    if (expError) {
                        console.error('Add resolve experience error:', expError);
                    }
                });

                // Log activity
                ActivityLogModel.create({
                    userId: resolverId,
                    action: 'vulnerability_resolved',
                    details: `Resolved vulnerability: ${vulnerability.title}`,
                    exp_gained: resolveExpReward
                }, (logError) => {
                    if (logError) {
                        console.error('Activity log error:', logError);
                    }
                });
            }

            res.json({
                success: true,
                message: `Vulnerability status updated to ${status}`,
                vulnerability: {
                    ...vulnerability,
                    status,
                    resolver_id: resolverId
                }
            });
        });
    });
};

// Get user vulnerabilities
const getUserVulnerabilities = (req, res) => {
    const userId = req.params.userId || req.userId;
    const { type = 'reported' } = req.query;

    if (type === 'reported') {
        VulnerabilityModel.getUserReported(userId, (error, vulnerabilities) => {
            if (error) {
                console.error('Get user reported vulnerabilities error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            res.json({
                success: true,
                type: 'reported',
                vulnerabilities
            });
        });
    } else if (type === 'resolved') {
        VulnerabilityModel.getUserResolved(userId, (error, vulnerabilities) => {
            if (error) {
                console.error('Get user resolved vulnerabilities error:', error);
                return res.status(500).json({ 
                    success: false, 
                    message: 'Server error' 
                });
            }

            res.json({
                success: true,
                type: 'resolved',
                vulnerabilities
            });
        });
    } else {
        res.status(400).json({
            success: false,
            message: 'Invalid type. Must be: reported or resolved'
        });
    }
};

module.exports = {
    createVulnerability,
    getVulnerabilities,
    getVulnerability,
    updateVulnerabilityStatus,
    getUserVulnerabilities
};